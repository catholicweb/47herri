<script>
function groupEvents(events, mappingFns) {
    if (mappingFns.length === 0) return events;
    const currentFn = mappingFns[0];
    const grouped = events.reduce((acc, event) => {
        const key_array = currentFn(event);
        for (var i = 0; i < key_array.length; i++) {
            let key = key_array[i]
            if (!acc[key]) acc[key] = [];
            acc[key].push(event);
        }
        return acc;
    }, {});
    // Se aplica recursivamente con el resto de funciones
    Object.keys(grouped).forEach(key => {
        grouped[key] = groupEvents(grouped[key], mappingFns.slice(1));
    });
    // Ordenamos las claves y creamos un nuevo objeto
    const sortedGrouped = {};
    Object.keys(grouped).sort().forEach(key => {
        sortedGrouped[key] = grouped[key];
    });

    return sortedGrouped;
}


const mappers = {
    location(event) {
        return [event.location]
    },
    time(event) {
        return event.times
    },
    none(event) {
        return [" "];
    },
    type(event) {
        return [event.type];
    },
    title(event) {
        return [event.title];
    },
    datetime(event) {
        return [`${event.dates[0]} - ${event.times[0]}`]
    },
    dates(event) {
        return event.dates
    },
    weekend(event) {
        return event.byday.map(el => ['igandea', 'larunbat'].includes(el) ? el : 'astegunetan');
    },
    byweek(event) {
        return event.byweek
    },
    weekday(event) {
        return event.byday;
    },
    notes(event) {
        let arr = event.notes ? [event.notes] : []
        let ordering = ['none', 'weekend', 'time', 'none', 'location', 'notes'] // TODO: very ugly fix
        if (!ordering.includes('byweek') && event.byweek.length && event.byweek.length < 5) {
            arr.push(event.byweek)
        }
        if (!ordering.includes('weekday') && event.byday.length && !['igandea', 'larunbat', 'astegunetan', 'asteguneta'].includes(event.byday[0])) {
            arr.push(event.byday)
        }
        let str = arr.join(', ').trim()
        return str ? [" (" + str + ")"] : [" "]
    }
}


const colorMap = { ' ': 'none' };

function getColorForKey(key) {
    const colors = ["#007bff", "#28a745", "#dc3545", "#ffc107", "#17a2b8", "#6f42c1", "#e83e8c", "#fd7e14"];
    if (!colorMap[key]) {
        colorMap[key] = colors[Object.keys(colorMap).length % colors.length];
    }
    return colorMap[key];
}


let eventsApp = {
    getSubKeys: function(table) {
        const keys = new Set();
        for (const row in table) {
            for (const subKey in table[row]) keys.add(subKey);
        }
        return Array.from(keys);
    },
    fetchEvents: async function() {
        let response = await fetch("/assets/events.json")
        let events = await response.json()
        this.events = events.slice(0, -1)
    },
    events: [],
    groupedEvents: function(filter, ordering) {
        let events = this.events.filter(event => filter.test(event.type));
        const mappingFns = ordering.map(fnc => mappers[fnc])
        return groupEvents(events, mappingFns);
    }
}
if (!window.vueApp) window.vueApp = {}
vueApp = { ...vueApp, ...eventsApp };
</script>
<template>
    {%- assign params = include.params -%}
    <div class="events" v-scope @vue:mounted="fetchEvents()">
        <!-- Primer grupo -->
        <div v-for="(group, groupKey) in groupedEvents({{ params.ordering }})" style="margin-bottom:20px;" class="row">
            <h1 class="col-12 heading_center">[[ groupKey.trim() ]]</h1>
            <!-- Segundo grupo: cada clave genera una tabla -->
            <div v-for="(table, tableKey) in group" style="margin-bottom:20px;" class="col-md-6 col-lg-4">
                <h3>[[ tableKey.trim() ]]</h3>
                <table border="1">
                    <thead v-if="getSubKeys(table)[0] != ' '">
                        <tr>
                            <th> </th>
                            <th v-for="subKey in getSubKeys(table)">[[ subKey.trim() ]]</th>
                        </tr>
                    </thead>
                    <tbody>
                        <!-- Segundo grupo -->
                        <tr v-for="(row, rowKey) in table">
                            <td>[[ rowKey.trim() ]]</td>
                            <td v-for="subKey in getSubKeys(table)">
                                <!-- Tercer grupo: elementos en la misma lÃ­nea -->
                                <p v-for="(line, lineKey) in row[subKey]" style="margin-right:10px; display: flex;">
                                    [[ lineKey.trim() ]]
                                    <span v-for="(item, itemKey) in line" :style="/*{ backgroundColor: getColorForKey(itemKey) }*/">[[ itemKey.trim() ]]</span>
                                </p>
                            </td>
                        </tr>
                    </tbody>
                </table>
            </div>
        </div>
    </div>
</template>

<head disable="already included">
    <script src="https://unpkg.com/petite-vue"></script>
</head>
<style>
.events table {
    width: 100%;
    border-collapse: collapse;
    margin-top: 10px;
    box-shadow: 0 4px 8px rgba(0, 0, 0, 0);
    border-radius: 8px;
    overflow: hidden;
}

.events {
    text-transform: capitalize;
}

.events th,
.events td {
    padding: 12px 16px;
    text-align: left;
}

.events th {
    background-color: #007bff;
    color: white;
    font-weight: bold;
}

.events tr:nth-child(even) {
    background-color: #f8f9fa;
}

.events p {
    margin: 0;
}

h1:empty,
h3:empty,
td:empty,
th:empty,
tr:empty,
span:empty {
    display: none !important;
}

.events h3 {
    color: #333;
    border-bottom: 3px solid #009C46;
    padding-bottom: 5px;
    margin-top: 20px;
    font-size: 1.4em;
}


.events span {
    /*display: inline-block;
    background-color: #007bff;
    color: white;
    margin-right: 6px;
    border-radius: 4px;*/
    font-style: italic;
    padding: 0px 4px;
    font-size: 0.7em;
}
</style>