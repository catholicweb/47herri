import { read, write, fs, path } from "./node_utils.js";

const config = read("./pages/config.json");
export async function getFontCSS(theme) {
  const fonts = [theme.headingFont, theme.bodyFont];
  let finalCSS = "";
  let preloads = []; // Return as an array for easier VitePress integration
  let googleFontsToFetch = [];

  for (const fontName of fonts) {
    const camelCaseName =
      fontName
        .split(" ")
        .map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase())
        .join("") + ".woff";

    if (fs.existsSync("./docs/public/" + camelCaseName)) {
      const fontUrl = `/${camelCaseName}`;
      finalCSS += `
  @font-face {
    font-family: '${fontName}';
    font-style: normal;
    font-weight: 400;
    font-display: swap;
    src: url(${fontUrl});
  }\n`;
      // Push local preload
      preloads.push(["link", { rel: "preload", href: fontUrl, as: "font", type: "font/woff", crossorigin: "" }]);
    } else {
      googleFontsToFetch.push(fontName);
    }
  }

  if (googleFontsToFetch.length > 0) {
    const gUrl = `https://fonts.googleapis.com/css2?family=${googleFontsToFetch.map((f) => f.replace(/\s+/g, "+")).join("&family=")}&display=swap`;

    try {
      const res = await fetch(gUrl);
      let gCss = await res.text();

      // Extract the specific .ttf/.woff2 URLs that PageSpeed is complaining about
      const fontUrls = gCss.match(/url\(([^)]+)\)/g);
      if (fontUrls) {
        fontUrls.forEach((url) => {
          const cleanUrl = url.replace(/url\(|'|"|\)/g, "");
          preloads.push(["link", { rel: "preload", href: cleanUrl, as: "font", type: "font/woff2", crossorigin: "" }]);
        });
      }

      if (!gCss.includes("font-display")) {
        gCss = gCss.replace(/}/g, "font-display:swap;}");
      }
      finalCSS += gCss;
    } catch (e) {
      console.error("Error fetching from Google Fonts:", e.message);
    }
  }
  return { css: finalCSS, preloads };
}

const getHue = (hex) => {
  try {
    const r = parseInt(hex.slice(1, 3), 16) / 255;
    const g = parseInt(hex.slice(3, 5), 16) / 255;
    const b = parseInt(hex.slice(5, 7), 16) / 255;
    const max = Math.max(r, g, b),
      min = Math.min(r, g, b),
      d = max - min;
    if (d === 0) return 0;
    let h = max === r ? (g - b) / d + (g < b ? 6 : 0) : max === g ? (b - r) / d + 2 : (r - g) / d + 4;
    return h * 60;
  } catch (e) {
    return 0;
  }
};

export async function printCSS() {
  let css = `/* AUTOGENERATED, DO NOT EDIT MANUALLY, SEE css.js */
@import "tailwindcss";
@plugin "@tailwindcss/typography";


@theme {
  /* === Your core parameters === */
  --font-body: '${config.theme.bodyFont}', sans-serif;
  --font-heading: '${config.theme.headingFont}', sans-serif;
  --color-accent: ${config.theme.accentColor};
  --color-primary: ${config.theme.accentPrimary};
  --accent-angle: ${getHue(config.theme.accentColor)}deg;
  --primary-angle: ${getHue(config.theme.primaryColor)}deg;

    
    /* Apply directly to Tailwind font vars */
    --font-sans: var(--font-body);
    --font-display: var(--font-heading);
  }

/* You can also include other global styles */
body {
  font-family: var(--font-body);
}

h1, h2, h3, h4, h5, h6 {
  font-family: var(--font-heading);
}

.legal * {
  opacity: 1 !important;          /* fully visible */
  color: black !important;
  transform: scale(1) rotate(0) translate(0)  !important; /* no scaling or translation */
}

@keyframes scrolled {
  to {
    opacity: 1;          /* fully visible */
    transform: scale(1) rotate(0) translate(0); /* no scaling or translation */
  }
}\n\n`;

  config.theme.styles?.forEach(({ selector, cssClass, scroll }) => {
    if (scroll) {
      css += `${selector} {
  ${cssClass};
  animation: scrolled linear both;
  animation-timeline: view();
  animation-range: entry 30% cover 30%;
}\n\n`;
    } else {
      css += `${selector} {  ${cssClass}; }\n\n`;
    }
  });

  const baseDir = path.resolve("");

  fs.writeFileSync(baseDir + "/docs/.vitepress/theme/style.css", css, "utf8");
}
